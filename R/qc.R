
#' Detect outliers based on robust linear regression of QQ plot
#'
#' @param x a vector of mahalanobis distance
#' @param df degree of freedom for chi-square distribution
#' @param conf confidence for linear regression
#'
#' @importFrom MASS rlm
#' @importFrom stats pchisq qnorm qchisq dchisq ppoints
#'
#' @return cell names of outliers
#'
.qq_outliers_robust <- function(x, df, conf) {
  n <- length(x)
  P <- ppoints(n)
  z <- stats::qchisq(P, df=df)
  ord.x <- x[order(x)]
  coef <- coef(MASS::rlm(ord.x ~ z, maxit=200))
  a <- coef[1]
  b <- coef[2]
  zz <- stats::qnorm(1 - (1 - conf)/2)
  SE <- (b/stats::dchisq(z, df))*sqrt(P*(1 - P)/n)
  fit.value <- a + b*z
  upper <- fit.value + zz*SE
  thr <- max(ord.x[ord.x < upper])
  return(names(x[x > thr]))
}


#' Detect outliers based on QC metrics
#'
#' @param scd an SCData object containing expression values and
#' QC metrics.
#' @param comp the number of component used in GMM. can be one or two.
#' @param sel_col a vector of column names, indicate the columns to use for QC.
#' by default it will be the statistics generated by `calculate_QC_metrics()`
#' @param type only looking at low quality cells (`low`) or possible doublets (`high`)
#' or both (`both`)
#' @param conf confidence interval for linear regression at lower and upper tails.
#' Usually this is smaller for lower tail because we hope to pick out more
#' low quality cells than doublets.
#' @details detect outlier using Mahalanobis distances TODO
#'
#' @return an updated SCData object with an outlier column in \code{QualityControlInfo}
#'
#' @import mclust robustbase
#' @importFrom stats cov pchisq mahalanobis complete.cases
#'
#' @export
#' @examples
#' #TODO
#'
detect_outlier <- function(scd,
                          comp=1,
                          sel_col=NULL,
                          type=c("both", "low", "high"),
                          conf=c(0.9, 0.99)) {
  type <- match.arg(type)

  # check format:
  if (is(scd, "SCData")) {
    if (is.null(sel_col)) {
      sel_col <- c("number_of_genes", "total_count_per_cell", "non_mt_percent",
                  "non_ERCC_percent", "non_ribo_percent")
    }
    if (!all(sel_col %in% colnames(QC_metrics(scd)))) {
      tmp <- sel_col[!(sel_col %in% colnames(QC_metrics(scd)))]
      print("the following QC metrics not find in data:")
      print(tmp)
    }
    x <- Biobase::pData(QC_metrics(scd))[, colnames(QC_metrics(scd)) %in% sel_col]
  }
  else{
    stop("scd must be an SCData object.")
  }
  if (!all(complete.cases(x))) {
    stop("we find NAs in the `QC_metrics(scd)`, check the quality control matrix")
  }
  if(is.null(dim(x))){
    warning("quality control metrics should be at least two dimensions.")
    QC_met <- pData(QC_metrics(scd))
    QC_met$outliers <- FALSE
    QC_metrics(scd) <- QC_met
    return(scd)
  }
  dist <- mahalanobis(x, center=colMeans(x), cov=cov(x))
  keep <- !(dist>qchisq(0.99, ncol(x)))
  mod <- Mclust(x[keep,],
               G=comp,
               modelNames="EEE",
               verbose = FALSE)

  if (comp == 1) {
    covr <- covMcd(x, alpha=0.7)
    dist <- mahalanobis(x,
                       center=covr$center,
                       cov=covr$cov)
    mean_diff <- sign(t(x)-covr$center)
    QC_sign <- c(-1, 1)[as.factor(apply(mean_diff, 2, function(t) {sum(t)>0}))]
    neg_dist <- dist[QC_sign == -1]
    pos_dist <- dist[QC_sign == 1]
    if (type == "both") {
      outlier_cells <- .qq_outliers_robust(neg_dist, ncol(x), conf[1])
      outlier_cells <- c(outlier_cells,
                        .qq_outliers_robust(pos_dist, ncol(x), conf[2]))
    }
    else if (type == "low") {
      outlier_cells <- .qq_outliers_robust(neg_dist, ncol(x), conf[1])
    }
    else if (type == "high") {
      outlier_cells <- .qq_outliers_robust(pos_dist, ncol(x), conf[2])
    }
  }
  else{
    ord_fst <- c(1:comp)[order(mod$parameters$mean[1,], decreasing <- TRUE)]
    poor_comp <- ord_fst[2:comp]
    good_comp <- ord_fst[1]
    keep1 <- rep(TRUE, nrow(x))
    keep1[keep][mod$classification %in% poor_comp] <- FALSE
    keep1[!keep] <- FALSE
    sub_x <- x[keep1,]
    covr <- covMcd(sub_x, alpha=0.7)
    sub_dist <- mahalanobis(sub_x,
                           center=covr$center,
                           cov=covr$cov)

    mean_diff <- sign(t(sub_x)-covr$center)
    QC_sign <- c(-1, 1)[as.factor(apply(mean_diff, 2, function(t) {sum(t)>0}))]
    neg_dist <- sub_dist[QC_sign == -1]
    pos_dist <- sub_dist[QC_sign == 1]
    outlier_cells <- .qq_outliers_robust(neg_dist, ncol(sub_x), conf[1])
    outlier_cells <- c(outlier_cells,
                      .qq_outliers_robust(pos_dist, ncol(sub_x), conf[2]))
    outlier_cells <- c(outlier_cells, rownames(x[!keep1,]))
    if (!(type == "both")) {
      mean_diff <- sign(t(x)-mod$parameters$mean[, good_comp])
      QC_sign <- c(-1, 1)[as.factor(apply(mean_diff, 2, function(t) {sum(t)>0}))]
      if (type == "low") {
        outlier_cells <- rownames(x)[(rownames(x) %in% outlier_cells) & (QC_sign == -1)]
      }
      else if (type == "high") {
        outlier_cells <- rownames(x)[(rownames(x) %in% outlier_cells) & (QC_sign == 1)]
      }
    }
  }
  outliers <- as.factor(rownames(x)  %in% outlier_cells)
  QC_met <- pData(QC_metrics(scd))
  QC_met$outliers <- outliers
  QC_metrics(scd) <- QC_met
  return(scd)
}


#' get QC metrics using gene counting matrix
#'
#' @param scd an SCData object containing count
#' @details get QC metrics using gene counting matrix
#' the QC statistics added are
#' `number_of_genes`: number of genes detected
#' `total_count_per_cell`: sum of read number after UMI dedup
#' `non_mt_percent`: 1- percent of mitochondrial gene counts
#' mitochondrial genes are retrived by GO term GO:0005739
#' `non_ERCC_percent`: ratio of exon counts to ERCC counts
#' `non_ribo_percent`: 1- percent of ribosomal gene counts
#' ribosomal genes are retrived by GO term GO:0005840
#' @return no return
#'
#' @importFrom Biobase exprs pData fData
#'
#' @export
#' @examples
#' #TODO
#'
calculate_QC_metrics <- function(scd) {
  if (is(scd, "SCData")) {
    exprs_mat <- switch(scd@useForExprs,
                        exprs=Biobase::exprs(scd),
                        tpm=tpm(scd),
                        cpm=cpm(scd),
                        fpkm=fpkm(scd),
                        counts=counts(scd))
  }
  else{
    stop("require a SCData object.")
  }
  QC_met <- Biobase::pData(QC_metrics(scd))
  # get ERCC ratio
  spikein <- Biobase::fData(scd)$isSpike
  exon_count <- colSums(exprs_mat[!spikein,])
  gene_number <- colSums(exprs_mat>0)
  if (all(gene_number == 0)) {
    stop("all gene have zero expression values. check your expression matrix.")
  }
  QC_met$total_count_per_cell <- exon_count
  QC_met$number_of_genes <- gene_number
  if (any(spikein)) {
    ERCC_count <- colSums(exprs_mat[spikein,])
    QC_met$non_ERCC_percent <- exon_count/(ERCC_count+exon_count)
  }
  else{
    print("cannot detect ERCC Spikeins from data. skip `non_ERCC_percent`.")
  }
  # get mt percentage
  if(!(gene_id_type(scd) == "NA")){
    mt_genes <- get_genes_by_GO(returns=gene_id_type(scd),
                                dataset=organism.SCData(scd),
                                go=c("GO:0005739"))
    if (length(mt_genes)>0) {
      if (any(rownames(exprs_mat) %in% mt_genes)) {
        mt_count <- colSums(exprs_mat[rownames(exprs_mat) %in% mt_genes,])
        QC_met$non_mt_percent <- (exon_count-mt_count)/(exon_count+0.01) # add 0.01 to make sure they are not NA
      }
    }
  }else{
    print("no gene_id_type, skip `non_mt_percent`")
  }




  # get ribosomal percentage
  if(!(gene_id_type(scd) == "NA")){
    ribo_genes <- get_genes_by_GO(returns=gene_id_type(scd),
                               dataset=organism.SCData(scd),
                               go=c("GO:0005840"))
    if (length(ribo_genes)>0) {
      if (any(rownames(exprs_mat) %in% ribo_genes)) {
        ribo_count <- colSums(exprs_mat[rownames(exprs_mat) %in% ribo_genes,])
        QC_met$non_ribo_percent <- (exon_count-ribo_count)/(exon_count+0.01)
      }
    }
  }else{
    print("no gene_id_type, skip `non_ribo_percent`")
  }
  QC_metrics(scd) <- QC_met
  return(scd)
}


#' plot QC statistics for SCData object
#' @param scd an SCData object
#' @param sel_col a vector of column names, indicate the columns to use for plot.
#' by default it will be the statistics generated by `calculate_QC_metrics()`
#' @importFrom GGally ggpairs
#' @import ggplot2
#' @export
#'
plotQC_pair <- function(scd, sel_col=NULL) {
  if (is(scd, "SCData")) {
    if (is.null(sel_col)) {
      sel_col <- c("number_of_genes", "total_count_per_cell", "non_mt_percent",
                   "non_ERCC_percent", "non_ribo_percent", "outliers")
    }
    x <- pData(QC_metrics(scd))[, colnames(QC_metrics(scd)) %in% sel_col]
  }
  else{
    stop("scd must be an SCData object.")
  }
  if ("outliers" %in% colnames(x)){
    return(ggpairs(x, mapping = ggplot2::aes_string(colour = "outliers")))
  }
  else{
    return(ggpairs(x))
  }
}

#' plot mapping statistics for SCData object.
#' @param scd an SCData object
#' @param sel_col a vector of column names, indicate the columns to use for plot.
#' by default it will be the mapping result.
#' @param percentage logic. whether to convert the number of reads to percentage
#' @param dataname the name of this dataset which appears in the plot title
#'
#' @import scales reshape ggplot2
#' @importFrom stats prcomp reorder
#'
#' @export
#'
plotMapping <- function(scd,
                        sel_col=NULL,
                        percentage=FALSE,
                        dataname="") {
  if (is(scd, "SCData")) {
    if (is.null(sel_col)) {
      sel_col <- c("unaligned", "aligned_unmapped", "ambiguous_mapping",
                   "mapped_to_ERCC", "mapped_to_intron", "mapped_to_exon")
    }
    x <- pData(QC_metrics(scd))[, sel_col]
  }
  else{
    stop("scd must be an SCData object.")
  }


  mapping_stat <- x
  mapping_stat$sample_name <- stats::reorder(rownames(mapping_stat), mapping_stat$mapped_to_exon)
  mapping_stat_prop <- as.data.frame(prop.table(as.matrix(mapping_stat[, sapply(mapping_stat, is.numeric)]), 1))
  mapping_stat_prop$sample_name <- mapping_stat$sample_name
  dat.m <- melt(mapping_stat, id.vars="sample_name")
  dat.m1 <- melt(mapping_stat_prop, id.vars="sample_name")

  if (!percentage) {
    p <- ggplot(dat.m, aes_string(x="sample_name", y="value", fill="variable")) + scale_fill_brewer(palette="Set1")+
      geom_bar(stat="identity", width=1)+
      ylab("number of reads")+
      xlab("cell sorted by number of reads mapped to exon")+
      theme(axis.title.x=element_blank(), axis.text.x=element_blank())+
      ggtitle(paste0("overall mapping statistics of ", dataname, " (number of reads)"))
  }
  else{
    p <- ggplot(dat.m1, aes_string(x="sample_name", y="value", fill="variable")) + scale_fill_brewer(palette="Set1")+
      geom_bar(stat="identity", width=1)+
      ylab("percentage of reads")+
      xlab("cell sorted by number of reads mapped_to_exon")+
      scale_y_continuous(labels=percent_format())+
      theme(axis.title.x=element_blank(), axis.text.x=element_blank())+
      ggtitle(paste0("overall mapping statistics of ", dataname, " (percentage)"))
  }

  return(p)
}


#' remove outliers for SCData
#' @param scd an SCData object
#' @export
#'
remove_outliers <- function(scd) {
  if (!is(scd, "SCData")) {
    stop("scd must be an SCData object.")
  }
  if (!("outliers" %in% colnames(pData(QC_metrics(scd))))) {
    stop("no outlier information. please run `detect_outlier()` first.")
  }
  out_cell <- pData(QC_metrics(scd))$outliers == FALSE
  return(scd[, out_cell])
}




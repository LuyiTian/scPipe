#' create SCData object from data folder generated by preprocessing step
#' 
#' after we run \code{sc_gene_counting} and finish the preprocessing step. \code{create_scd_by_dir}
#' can be used to generate the SCData obeject from the folder that contains gene counting matrix and QC statistics.
#' it can also generate the html report based on the gene count and quality control statistics
#'
#' @param datadir the directory that contains all the data and `stat` subfolder.
#' @param organism the organism of the data. List of possible names can be retrieved using the function 
#' `listDatasets`from `biomaRt` package. (i.e `mmusculus_gene_ensembl` or `hsapiens_gene_ensembl`)
#' @param gene_id_type gene id type of the data A possible list of ids can be retrieved using the function `listAttributes` from `biomaRt` package. 
#' the commonly used id types are `external_gene_name`, `ensembl_gene_id` or `entrezgene`
#' @param pheno_data the external phenotype data that linked to each single cell. this should be an \code{AnnotatedDataFrame} object
#' @param report whether to generate the html report in the data folder
#' 
#' @details after we run \code{sc_gene_counting} and finish the preprocessing step. \code{create_scd_by_dir}
#' can be used to generate the SCData obeject from the folder that contains gene counting matrix and QC statistics.
#' 
#' @return an SCData object
#'
#' @importFrom utils read.csv
#'
#' @export
#' 
#' @examples 
#' \dontrun{
#' # the scd can be created fron the output folder of scPipe
#' scd = create_scd_by_dir(datadir="output_dir_of_scPipe",organism="mmusculus_gene_ensembl",gene_id_type="ensembl_gene_id",report=TRUE)
#' }
#' # or directly from the gene count and quality control matrix:
#' data("sc_sample_data")
#' data("sc_sample_qc")
#' QualityControlInfo = new("AnnotatedDataFrame", data = as.data.frame(sc_sample_qc))
#' scd = newSCData(countData = as.matrix(sc_sample_data),
#'                QualityControlInfo = QualityControlInfo,
#'                useForExprs = "counts",
#'                organism = "mmusculus_gene_ensembl",
#'                gene_id_type = "external_gene_name")
#' 

create_scd_by_dir = function(datadir, organism=NULL, gene_id_type=NULL, pheno_data=NULL, report=FALSE) {
  gene_cnt = read.csv(file.path(datadir, "gene_count.csv"), row.names=1)
  cell_stat = read.csv(file.path(datadir, "stat", "cell_stat.csv"), row.names=1)
  
  gene_cnt = gene_cnt[, order(colnames(gene_cnt))]
  cell_stat = cell_stat[order(rownames(cell_stat)), ]
  
  
  QualityControlInfo = new("AnnotatedDataFrame", data = as.data.frame(cell_stat))
  scd = newSCData(countData = as.matrix(gene_cnt),
                  QualityControlInfo = QualityControlInfo,
                  phenoData = pheno_data,
                  useForExprs = "counts",
                  organism = organism,
                  gene_id_type = gene_id_type)
  if(report){
    create_report(sample_name=basename(datadir),
                             outdir=datadir,
                             r1="NA",
                             r2="NA",
                             outfq="NA",
                             read_structure = list(bs1=1, bl1=1, bs2=1, bl2=1, us=1, ul=1),
                             filter_settings = list(rmlow = TRUE, rmN = TRUE, minq = 20, numbq = 2),
                             align_bam = "NA",
                             genome_index = "NA",
                             map_bam = "NA",
                             exon_anno = "NA",
                             stnd = TRUE,
                             fix_chr=FALSE,
                             barcode_anno="NA",
                             max_mis=1,
                             UMI_cor=1,
                             gene_fl=FALSE,
                             organism=organism,
                             gene_id_type=gene_id_type)
  }

  
  return(scd)
}


#' create_report
#' 
#' create html report using data generated by proprocessing step.
#'
#' @param sample_name sample name
#' @param outdir output folder
#' @param r1 file path of read1
#' @param r2 file path of read2 default to be NULL
#' @param outfq file path of the output of \code{sc_trim_barcode}
#' @param read_structure a list contains read structure configuration. for more help see `?sc_trim_barcode`
#' @param filter_settings a list contains read filter settings for more help see `?sc_trim_barcode`
#' @param align_bam the aligned bam file
#' @param genome_index genome index used for alignment
#' @param map_bam the mapped bam file
#' @param exon_anno the gff exon annotation used. can have multiple files
#' @param stnd whether to perform strand specific mapping
#' @param fix_chr add `chr` to chromosome names, fix inconsistant names.
#' @param barcode_anno cell barcode annotation file path.
#' @param max_mis maximum mismatch allowed in barcode. default to be 1
#' @param UMI_cor correct UMI sequence error: 0 means no correction, 1 means simple correction and merge UMI with distance 1.
#' @param gene_fl whether to remove low abundant gene count. low abundant is defined as only one copy of one UMI for this gene
#' @param organism the organism of the data. List of possible names can be retrieved using the function 
#' `listDatasets`from `biomaRt` package. (i.e `mmusculus_gene_ensembl` or `hsapiens_gene_ensembl`)
#' @param gene_id_type gene id type of the data A possible list of ids can be retrieved using the function `listAttributes` from `biomaRt` package. 
#' the commonly used id types are `external_gene_name`, `ensembl_gene_id` or `entrezgene`
#'
#' @return no return
#' @export
#' 
#' @examples 
#' \dontrun{
#' create_report(sample_name="sample_001",
#'        outdir="output_dir_of_scPipe",
#'        r1="read1.fq",
#'        r2="read2.fq",
#'        outfq="trim.fq",
#'        read_structure=list(bs1=-1, bl1=2, bs2=6, bl2=8, us=0, ul=6),
#'        filter_settings=list(rmlow=TRUE, rmN=TRUE, minq=20, numbq=2),
#'        align_bam="align.bam",
#'        genome_index="mouse.index",
#'        map_bam="aligned.mapped.bam",
#'        exon_anno="exon_anno.gff3",
#'        stnd=TRUE,
#'        fix_chr=FALSE,
#'        barcode_anno="cell_barcode.csv",
#'        max_mis=1,
#'        UMI_cor=1,
#'        gene_fl=FALSE,
#'        organism="mmusculus_gene_ensembl",
#'        gene_id_type="ensembl_gene_id")
#' }
#'
create_report = function(sample_name,
                         outdir,
                         r1,
                         r2=NULL,
                         outfq,
                         read_structure,
                         filter_settings,
                         align_bam,
                         genome_index,
                         map_bam,
                         exon_anno,
                         stnd,
                         fix_chr,
                         barcode_anno,
                         max_mis,
                         UMI_cor,
                         gene_fl,
                         organism,
                         gene_id_type) {
  fn = system.file("extdata", "report_template.Rmd", package = "scPipe")
  tx = readLines(fn)
  
  tx = gsub(pattern = "SAMPLE_NAME__", replacement = sample_name, x = tx)
  tx = gsub(pattern = "FQ1__", replacement = r1, x = tx)
  if (!is.null(r2)) {
    tx = gsub(pattern = "FQ2__", replacement = r2, x = tx)
  }
  else {
    tx = gsub(pattern = "FQ2__", replacement = "NA", x = tx)
  }
  
  tx = gsub(pattern = "FQOUT__", replacement = outfq, x = tx)
  if (read_structure$bs1<0) {
    tx = gsub(pattern = "BC1_INFO__", replacement = "NA", x = tx)
  }
  else {
    tx = gsub(pattern = "BC1_INFO__", replacement = 
                paste0("start at position ", read_structure$bs1, ", length ", read_structure$bl1), x = tx)
  }
  
  tx = gsub(pattern = "BC1_INFO__", replacement = 
              paste0("start at position ", read_structure$bs2, ", length ", read_structure$bl2), x = tx)
  tx = gsub(pattern = "UMI_INFO__", replacement = 
              paste0("start at position ", read_structure$us, ", length ", read_structure$ul), x = tx)
  
  tx = gsub(pattern = "RM_N__", replacement = as.character(filter_settings$rmN), x = tx)
  tx = gsub(pattern = "RM_LOW__", replacement = as.character(filter_settings$rmlow), x = tx)
  tx = gsub(pattern = "MIN_Q__", replacement = filter_settings$minq, x = tx)
  tx = gsub(pattern = "NUM_BQ__", replacement = filter_settings$numbq, x = tx)
  
  tx = gsub(pattern = "BAM_ALIGN__", replacement = align_bam, x = tx)
  tx = gsub(pattern = "G_INDEX__", replacement = genome_index, x = tx)
  tx = gsub(pattern = "BAM_MAP__", replacement = map_bam, x = tx)
  
  tx = gsub(pattern = "OUTDIR__", replacement = outdir, x = tx)
  tx = gsub(pattern = "ANNO_GFF__", replacement = paste(exon_anno, collapse=", "), x = tx)
  
  tx = gsub(pattern = "STND__", replacement = as.character(stnd), x = tx)
  tx = gsub(pattern = "FIX_CHR__", replacement = as.character(fix_chr), x = tx)
  tx = gsub(pattern = "BC_ANNO__", replacement = barcode_anno, x = tx)
  tx = gsub(pattern = "MAX_MIS__", replacement = max_mis, x = tx)
  
  if (UMI_cor == 1) {
    tx = gsub(pattern = "UMI_COR__", replacement = "simple correction and merge UMI with distance 1", x = tx)
  }
  else if (UMI_cor == 0) {
    tx = gsub(pattern = "UMI_COR__", replacement = "no correction", x = tx)
  }
  else {
    tx = gsub(pattern = "UMI_COR__", replacement = "unknown", x = tx)
  }
  
  tx = gsub(pattern = "GENE_FL__", replacement = as.character(gene_fl), x = tx)
  if(!missing(organism)){
    if(!is.null(organism)){
      tx = gsub(pattern = "SPECIES__", replacement = organism, x = tx)
    }
  }
  if(!missing(gene_id_type)){
    if(!is.null(gene_id_type)){
      tx = gsub(pattern = "GENE_ID_TYPE__", replacement = gene_id_type, x = tx)
    }
   
  }
  
  writeLines(tx, con=file.path(outdir, "report.Rmd"))
  knitr::wrap_rmd(file.path(outdir, "report.Rmd"), width = 120, backup = NULL)
  rmarkdown::render(file.path(outdir, "report.Rmd"), output_file = file.path(outdir, "report.html"))
}


#' run_scPipe
#'
#' @param sample_name sample names, the name should not have any space.
#' @param outdir the output folder
#' @param r1 file path of read1
#' @param r2 file path of read2
#' @param read_structure a list contains read structure configuration. for more help see `?sc_trim_barcode`
#' @param filter_settings a list contains read filter settings for more help see `?sc_trim_barcode`
#' @param genome_index genome index used for \code{Rsubread::align}
#' @param exon_anno a vector of gff exon annotation file paths.
#' @param fix_chr whether add `chr` to chromosome names, fix inconsistant names between different annotations.
#' @param barcode_anno file path for cell barcode annotation.
#' @param max_mis maximum mismatch allowed in barcode. default to be 1
#' @param has_UMI whether the protocol has UMI, default to be TRUE
#' @param UMI_cor correct UMI sequence error: 0 means no correction, 1 means simple correction and merge UMI with distance 1.
#' @param gene_fl whether to remove low abundant gene count. low abundant is defined as only one copy of one UMI for this gene
#' @param organism the organism of the data. List of possible names can be retrieved using the function 
#' `listDatasets`from `biomaRt` package. (i.e `mmusculus_gene_ensembl` or `hsapiens_gene_ensembl`)
#' @param gene_id_type gene id type of the data A possible list of ids can be retrieved using the function `listAttributes` from `biomaRt` package. 
#' the commonly used id types are `external_gene_name`, `ensembl_gene_id` or `entrezgene`
#' @param nthreads number of threads used
#' @param report whether to generate the html report
#'
#' @return an SCData object
#'
#' @importFrom Rsubread align
#'
#' @export
#' 
#' @examples 
#' \dontrun{
#'  # geneate scd from fastq files
#'  scd = run_scPipe(sample_name="sample_001",
#'        outdir="output_dir_of_scPipe",
#'        r1="read1.fq",
#'        r2="read2.fq",
#'        read_structure=list(bs1=-1, bl1=2, bs2=6, bl2=8, us=0, ul=6),
#'        filter_settings=list(rmlow=TRUE, rmN=TRUE, minq=20, numbq=2),
#'        genome_index="mouse.index",
#'        exon_anno="exon_anno.gff3",
#'        has_UMI=TRUE,
#'        stnd=TRUE,
#'        fix_chr=FALSE,
#'        barcode_anno="cell_barcode.csv",
#'        max_mis=1,
#'        UMI_cor=1,
#'        gene_fl=FALSE,
#'        nthreads=1,
#'        report=TRUE,
#'        organism="mmusculus_gene_ensembl",
#'        gene_id_type="ensembl_gene_id")
#' }
#' # or directly from the gene count and quality control matrix:
#' data("sc_sample_data")
#' data("sc_sample_qc")
#' QualityControlInfo = new("AnnotatedDataFrame", data = as.data.frame(sc_sample_qc))
#' scd = newSCData(countData = as.matrix(sc_sample_data),
#'                QualityControlInfo = QualityControlInfo,
#'                useForExprs = "counts",
#'                organism = "mmusculus_gene_ensembl",
#'                gene_id_type = "external_gene_name")
run_scPipe <- function(sample_name,
                      outdir,
                      r1,
                      r2=NULL,
                      read_structure,
                      filter_settings=list(rmlow = TRUE, rmN = TRUE, minq = 20, numbq = 2),
                      genome_index,
                      exon_anno,
                      fix_chr=FALSE,
                      barcode_anno=NULL,
                      max_mis=1,
                      has_UMI=TRUE,
                      UMI_cor=1,
                      gene_fl=FALSE,
                      organism="NA",
                      gene_id_type="NA",
                      nthreads=1,
                      report=TRUE) {
  out_fq = file.path(outdir, paste0(sample_name, ".fq"))
  bam_align = file.path(outdir, paste0(sample_name, ".align.bam"))
  bam_map = file.path(outdir, paste0(sample_name, ".mapped.bam"))
  if (read_structure$bs1<0) {
    bc_len = read_structure$bl1+read_structure$bl2
  }
  else {
    bc_len = read_structure$bl2
  }
  sc_trim_barcode(outfq=out_fq,
                  r1=r1,
                  r2=r2,
                  read_structure=read_structure,
                  filter_settings=filter_settings)
  Rsubread::align(index=genome_index,
                  readfile1=out_fq,
                  output_file=bam_align,
                  nthread=nthreads)
  sc_exon_mapping(inbam=bam_align,
                  outbam=bam_map,
                  annofn=exon_anno,
                  stnd=TRUE,
                  bc_len=bc_len,
                  UMI_len=read_structure$ul,
                  fix_chr=FALSE)
  if (is.null(barcode_anno)) { # for Drop-seq
    bc_annotation = file.path(outdir, "cellindex_annotation.csv")
    sc_detect_bc(infq=out_fq,
                 outcsv=bc_annotation,
                 bc_len=bc_len)
  }
  else { # for CEL-seq
    bc_annotation = barcode_anno
  }
  
  sc_demultiplex(inbam=bam_map,
                 outdir=outdir,
                 bc_anno=bc_annotation,
                 max_mis=max_mis,
                 has_UMI=has_UMI)
  sc_gene_counting(outdir=outdir,
                   bc_anno=bc_annotation,
                   UMI_cor=UMI_cor,
                   gene_fl=gene_fl)

  scd = create_scd_by_dir(datadir=outdir, organism=organism, gene_id_type=gene_id_type)
  if (report) {
    create_report(sample_name=sample_name,
                  outdir=outdir,
                  r1=r1,
                  r2=r2,
                  outfq=out_fq,
                  read_structure=read_structure,
                  filter_settings=filter_settings,
                  align_bam=bam_align,
                  genome_index=genome_index,
                  map_bam=bam_map,
                  exon_anno=exon_anno,
                  stnd=TRUE,
                  fix_chr=fix_chr,
                  barcode_anno=bc_annotation,
                  max_mis=max_mis,
                  UMI_cor=UMI_cor,
                  gene_fl=gene_fl,
                  organism=organism,
                  gene_id_type=gene_id_type)
  }

  return(scd)
}
